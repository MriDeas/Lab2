1 基础知识

  - CPU性能
    - 主要看CPU 主频、核心数、缓存等参数，表现出来的是计算能力和指令执行能力
    - 其次要考虑CPU架构，“麒麟 980”采用三级能效架构，2 个 2.6GHz 主频的 A76 超大核 + 2 个 1.92GHz 主频的 A76 大核 + 4 个 1.8GHz主频的 A55
      小核。相比之下，“A12”使用 2 个性能核心 + 4 个能效核心的架构，这样设计主要是为了在日常低负荷工作时，使用低频核心更加节省电量
    - 获取CPU信息
          - adb shell cat /sys/devices/system/cpu/possible       获取 CPU 核心数
          - cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq 获取某个 CPU 的频率，切换cpu0/cpu1/cpu2..即可

  - 卡顿分析指标

    - CPU 占用率，假如长期大于 60% ，表示系统处于繁忙状态，就需要进一步分析用户时间和系统时间的比例。
      - 常用命令：
                - top 命令可以帮助我们查看哪个进程是 CPU 的消耗大户
                - vmstat 命令可以实时动态监视操作系统的虚拟内存和 CPU 活动
                - strace 命令可以跟踪某个进程中所有的系统调用

    - CPU饱和度  （CPU 饱和度反映的是线程排队等待 CPU 的情况，也就是 CPU 的负载情况）
      - CPU 饱和度首先会跟应用的线程数有关，如果启动的线程过多，容易导致系统不断地切换执行的线程，把大量的时间浪费在上下文切换，
        每一次 CPU 上下文切换都需要刷新寄存器和计数器，至少需要几十纳秒。
      - 影响 CPU 饱和度的还有线程优先级。线程优先级会影响 Android 系统的调度策略，它主要由 nice 和 cgroup 类型共同决定。nice 值越低，
        抢占 CPU 时间片的能力越强。当 CPU 空闲时，线程的优先级对执行效率的影响并不会特别明显，但在 CPU 繁忙的时候，线程调度会对执行效率有非常大的影响。


    - Android 卡顿排查工具

      - 从实现上该类排查工具分为两个流派：
        - 1 instrument ： 获取一段时间内所有函数的调用过程，可以通过分析这段时间内的函数调用流程，再进一步分析待优化的点
        - 2 sample ： 有选择性或者采用抽样的方式观察某些函数调用过程，可以通过这些有限的信息推测出流程中的可疑点，然后再继续细化分析


      - 工具1 Traceview

        - Traceview 属于 instrument 类型，它利用 Android Runtime 函数调用的 event 事件，将函数运行的耗时和调用关系写入 trace 文件中，
          以用来查看整个过程有哪些函数调用，但是工具本身带来的性能开销过大，有时无法反映真实的情况。
        - 5.0以后添加了startMethodTracingSampling方法，可以使用基于样本的方式进行分析，以减少分析对运行时的性能影响。

        - 缺点： 无法反混淆，耗性能

      - 工具2 Nanoscope

        - 它的实现原理是直接修改 Android 虚拟机源码，在ArtMethod执行入口和执行结束位置增加埋点代码，将所有的信息先写到内存，
          等到 trace 结束后才统一生成结果文件。
        - 支持分析任意一个应用，可用于做竞品分析
        - 限制： 需要自己刷 ROM；默认只支持主线程采集，其他线程需要代码手动设置；考虑到内存大小的限制，每个线程的内存数组只能支持大约 20 秒左右的时间段
        - Nanoscope 生成的是符合 Chrome tracing 规范的 HTML 文件

      - 工具3 systrace

        - Android 4.1 新增的性能分析工具，systrace 利用了 Linux 的ftrace调试工具，相当于在系统各个关键位置都添加了一些性能探针，
          也就是在代码里加了一些性能监控的埋点。Android 在 ftrace 的基础上封装了atrace，并增加了更多特有的探针，例如 Graphics、Activity Manager、Dalvik VM、System Server 等。
        - systrace 工具只能监控特定系统调用的耗时情况，所以它是属于 sample 类型，而且性能开销非常低。可以使用 systrace 跟踪系统的 I/O 操作、
          CPU 负载、Surface 渲染、GC 等事件。
        - 不支持应用程序代码的耗时分析

        - 如何在 systrace 上面自动增加应用程序的耗时分析：
          - 在重要函数的入口和出口分别增加Trace.beginSection和Trace.endSection
          这样做的好处：
             - 可以看到整个流程系统和应用程序的调用流程。包括系统关键线程的函数调用，例如渲染耗时、线程锁，GC 耗时等
             - 性能损耗可以接受。由于过滤了大部分的短函数，而且没有放大 I/O，所以整个运行耗时不到原来的两倍，基本可以反映真实情况

     - 工具4 Simpleperf

        - 分析 Native 函数的调用。Android 5.0 新增了Simpleperf性能分析工具，它利用 CPU 的性能监控单元（PMU）提供的硬件 perf 事件。
        - Simpleperf 同时封装了 systrace 的监控功能，通过 Android 几个版本的优化，现在 Simpleperf 比较友好地支持 Java 代码的性能分析。
        - Simpleperf 是属于 sample 类型，它的性能开销非常低，使用火焰图展示分析结果。

     - 工具5 可视化 Android Studio Profiler

        - Android Studio 3.2 的 Profiler 中直接集成了几种性能分析工具：

          - Sample Java Methods 的功能类似于 Traceview 的 sample 类型
          - Trace Java Methods 的功能类似于 Traceview 的 instrument 类型
          - Trace System Calls 的功能类似于 systrace
          - SampleNative (API Level 26+) 的功能类似于 Simpleperf

        - 这些分析工具都支持了 Call Chart(调用表) 和 Flame Chart(火焰图) 两种展示方式
          - Call Chart
             - 是 Traceview 和 systrace 默认使用的展示方式。它按照应用程序的函数执行顺序来展示，适合用于分析整个流程的调用。
               我们可以看到在这一段时间内，各个线程的具体工作，比如是否存在线程间的锁、主线程是否存在长时间的 I/O 操作、是否存在空闲。
          - Flame Chart
             - 以一个全局的视野来看待一段时间的调用分布，它就像给应用程序拍 X 光片，可以很自然地把时间和空间两个维度上的信息融合在一张图上。
               当我们不想知道应用程序的整个调用流程，只想直观看出哪些代码路径花费的 CPU 时间较多时，火焰图就是一个非常好的选择。

     - 简单总结

       - 如果需要分析 Native 代码的耗时，可以选择 Simpleperf
       - 如果想分析系统调用，可以选择 systrace
       - 如果想分析整个程序执行流程的耗时，可以选择 Traceview 或者插桩版本的 systrace

       /proc/[pid]/stat // 进程CPU使用情况
       /proc/[pid]/task/[tid]/stat // 进程下面各个线程的CPU使用情况
       /proc/[pid]/sched // 进程CPU调度相关
       /proc/loadavg // 系统平均负载，uptime命令对应文件






