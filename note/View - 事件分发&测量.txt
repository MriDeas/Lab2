- 1. 事件分发

- View之间的事件分发本质上试一个大的递归循环，关键函数dispatchTouchEvent的主要逻辑内容如下：
  - 1 检查ViewGroup是否需要拦截事件
  - 2 将事件分发给子View
  - 3 根据mFirstTouchTarget再次分发事件


- View 事件分发重点在于View本身对于事件的处理，是否有相应的手势逻辑(滑动、放大、点击等)来处理
  - 是否存在onTouchListener
  - 是否接收处理事件，即onTouchEvent函数

- ViewGroup 事件派发主要来处理与子view之间的逻辑
  - 当前Group是否拦截touch事件
  - 是否需要继续将touch事件分发给子View
  - 如何将touch事件派发给子View

-----------------------------------------------------------------------------------

- 步骤一：拦截事件的判断
  - 当前touch事件是DOWN事件或mFirstTouchTarget不为空(表示已发现有子View捕获了该事件，即子View的dispatchTouchEvent返回true)时调用onInterceptTouchEvent函数判断
    父View是否需要拦截事件

- 步骤二：不拦截时的处理逻辑
    - 如果是Down事件，则主动分发事件
    - 遍历所有子view
    - 调用dispatchTransformedTouchEvent将事件分发给子View，如果子view捕获成功，将mFirstTouchTarget赋值给子View

- 步骤三：
    - 有两个分支判断
      - 1 此时 mFirstTouchTarget != null，说明本次事件分发中还没有子View捕获该事件。这种情况下调用dispatchTransformedTouchEvent函数并传入为null的child，最终调用
          super.dispatchTouchEvent() -> ViewGroup自身的onTouchEvent函数进行事件的处理
      - 2 mFirstTouchTarget != null，说明步骤2中有子View对事件进行了捕获，则直接将当前和后续的事件交给mFirstTouchTarget指向的子View


- DOWN 事件
  - 所有事件是以DOWN事件开始的，DOWN事件的处理结果会影响后续MOVE、UP等事件的处理逻辑
  - 一旦子View捕获成功DOWN事件，后续的MOVE、UP事件会交给子View处理，即MOVE、UP事件分发给谁取决于它的起始事件DOWN是由谁捕获的

- mFirstTouchTarget
  - mFirstTouchTarget是一个TouchTarget类型的链表结构，作用是用来记录捕获了DOWN事件的View，存储于其内部View属性child中。Android支持多指操作，每个手指的DOWN事件都可看做
    是一个TouchTarget保存起来。

- Cancel事件

   - 当有子View捕获了事件且intercepted标记为true，表示父View将拦截并处理touch事件，这时父View会传递给子View的事件中传入cancelChild==true，
     这个事件最终被包装成Cancel事件传递给子View
   - Cancel的触发逻辑：
     - 当父View的 onInterceptTouchEvent 先返回false，然后在子View的dispatchTouchEvent中返回true，表示子View捕获了该事件，接下来的MOVE过程中
       父视图的onInterceptTouchEvent又返回true，intercepted被重置为true，此时该逻辑会被触发


- 2 测量

   - LayoutParams
   - MeasureSpec

   - View的测量

     - View.measure(int widthMeasureSpec, int heightMeasureSpec)函数被父View调用，传入尺寸和模式，调用onMeasure(int.,int.)函数
     - onMeasure(int widthMeasureSpec, int heightMeasureSpec)
        - 调用setMeasuredDimension(width，height)将所获得的宽高保存，具体过程如下：
           - 1 -> getSuggestedMinimumWidth(),判断background是否为空，是的话返回mMinWidth或mMinHeight的值，否则选择
                backrgound.getMinimumWidth/Height()和 mMinWidth/mMinHeight的最大值.
           - 2 -> getDefaultSize(getSuggestedMinimumWidth(int,int))
                   - 获得尺寸(sepcSize)和测量模式(specMode)
                   - 如果specMode是AT_MOST或EXACTLY，那么将给定的尺寸作为结果返回，AT_MOST对应了wrap_content，EXACTLY对应了具体的大小值或match_parent



   - ViewGroup的测量

     - ViewRootImpl的performMeasure()函数会执行mView.measure(childWidthMeasureSpec, childHeightMeasureSpec),ViewGroup没有重写measure()，此时调用
       View.measure() -> onMeasure(),自定义ViewGroup时，onMeasure()由开发者实现，例如系统提供的布局FrameLayout、RelativeLayout等都各自实现自己的方法。
       ViewGroup提供了一系列函数方便子View的测量：

        - measureChildren(int widthMeasureSpec, int heightMeasureSpec) 遍历所有的子View，执行measureChild() 撇开测量GONE类型的视图
        - measureChild(View child, int parentWidthMeasureSpec,int parentHeightMeasureSpec)
                 - child.getLayoutParams() 获取子View的宽高信息

                 - getChildMeasureSpec(parentWidthMeasureSpec,mPaddingLeft + mPaddingRight, lp.width)  根据父View测量模式信息获得子View的测量信息

                   - getChildMeasureSpec(int spec, int padding, int childDimension)
                            - 1 获得父View的specMode以及specSize，并且根据specSize - padding后和0之间取一个较大的值
                            - 2 判断specMode为不同的模式时，结合子View的大小计算出子View的MeasureSpec
                                   - 2.1  MeasureSpec.EXACTLY  父View有确定的大小
                                          - 子View的宽高信息>=0，子View的宽高不变，子View的specMode是EXACTLY
                                          - 子View的宽高是MATCH_PARENT,子View的尺寸是父View的尺寸大小，子View的specMode是EXACTLY
                                          - 子View的宽高是WRAP_CONTENT，子View的尺寸仍是父View的尺寸大小，但其specMode实AT_MOST


                 - child.measure(childWidthMeasureSpec, childHeightMeasureSpec)
































