Activity 启动模式 - 任务栈分析

- launchMode
- taskAffinity
- allowTaskReparenting
- flag


- 启动模式分析（1） 单进程模式

  - standard  默认模式，会启动一个新的Activity实例放入Task任务栈中，该模式下为Activity设置单独的taskAffinity没有效果，仅有一个任务栈

  - singleTop
          - 若任务栈中已有该实例且正在和用户产生交互(栈顶) ,则回调该实例的onNewIntent()函数，在此之前会回调该实例的onPause函数，该函数执行后会回调onResume函数
          - 若当前任务栈中没有该实例，则会创建新的实例放入栈顶，同standard
          - 该启动模式没有影响任务栈的创建和数量
  - singleTask
        - 相同的taskAffinity
          - 该模式不会创建新的任务栈
          - 若任务栈中有该实例，则会清除该实例以上的其他Activity实例，并回调该实例的onNewIntent()函数和onRestart、onStart、onResume生命周期，
            其次会在onNewIntent之前调用上一个Activity实例的onPause、然后在onResume之后回调上一个Activity实例的onStop、onDestroy

        - 不同的taskAffinity
          - 若新启动的Activity实例指定了不同的taskAffinity，该模式下会创建新的任务栈并将该实例放入新的任务栈中的顶部
          - 指定了singleTask模式的Activity启动新的Activity时，若新的Activity的taskAffinity没有指定(默认和之前的任务栈一致)或者指定和之前的任务栈一致，那么新的Activity
            实例会放进指定了singleTask模式而创建的新的任务栈中，而不是在此之前的任务栈中（前提是新启动的Activity的启动模式是standard）,当前应用会出现两个任务栈在系统最近
            任务列表中，此时按HOME键返回桌面再点击应用图标启动应用，则出现的是启动singleTask模式Activity的源Activity


  - singleInstance
        - 相同的taskAffinity
             - 此时设置该模式的Activity实例会出现在新的任务栈顶部
             - 以该模式启动的Activity所在的任务栈，若按Home键返回桌面，然后再点击应用图标启动该应用时，该Activity所在的任务栈仍将保留，但Activity处于隐藏的状态，手机最近任务里
               仅会显示一个任务栈，当再次启动该Activity时，则会回调该Activity的onNewIntent函数，取消隐藏
             - 在singleInstance模式的Activity中启动标准模式的Activity，新的Activity实例会出现在启动singleInstance模式Activity的源Activity实例所在的任务栈的栈顶，也就是
               当前该应用(单进程情况)中有两个任务栈。
                  - 返回键  此时点击返回键，新的Activity退出，而启动singleInstance模式Activity的源Activity所属的任务栈恢复，该Activity恢复在栈顶
             - 继续以上例子，当新启动的Activity(standard)实例再次启动singleInstance模式Activity时，目标Activity会回调onNewIntent()函数，而新的Activity则会
               -> onSaveInstanceState  -> onStop，最终处于onStop状态。
             - 假设 A、B、C三个Activity，其中B是singleInstance模式，启动关系如下 -> A -> B -> C，此时依次按返回键返回，在C中按返回键会让A处于栈顶，在A中继续按返回键
               B将会出现

 - 启动模式分析（2 多进程模式）

   - 应用P1和应用P2，P1的应用Activity成为P1-Act-1，应用P2的Activity成为 P2-Act-1

   - standard
       - 该模式下由P1的Act-1（singleTask或standard模式）启动P2-Act-1(standard模式)，则二者将位于同一任务栈中
       - 若P1进程的Activity是singleInstance模式，P2=Act-1(standard或singleTask模式)，则两个Activity位于两个不同的栈中
       - Home键 -> standard模式的P1-Act-1启动standard模式的P2-Act-2，二者处于相同任务栈中，按下HOME键再点击P1图标，P1进程的Act-2仍位于
         P1-Act1的任务栈中，点击返回键后P2-Act2将从此任务栈中退出
       - 若P1-Act-1是singleTask模式，启动P2-Act-2(standard模式)二者将位于同一任务栈中
   - singleTask
       - 若P1-Act-1启动P1-Act-2,Act-2是singleTask模式且taskAffinity与Act-1所处的task不同，P1-Act2在启动P2-Act-2时：
           - 若P2-Act-2的启动模式是singleTask模式且其taskAffinity是和P1-Act-1相同，那么P2-Act-2将和P1-Act-1处于相同的栈中,此时
             按HOME键之后再点击P1的图标，显示的页面是P2-Act-2，点击返回键则返回至P1-Act1页面



- allowTaskReparenting
    - P1-Act1 启动P2-Act2，P2-Act2的allowTaskReparenting=true，此时返回桌面再点击P1的图标，P2-Act2从P1-Act1的任务栈中消失
    - P1-Act1 启动P2-Act2，P2-Act2的allowTaskReparenting=true，按HOME键，点击P2应用的图标，P2-Act2从P1-Act1的任务栈中消失出现在
      P2应用的任务栈中

 - 总结
   - 除singleInstance模式以外，taskAffinity和singleTask模式结合，才能创建出新的任务栈
   - 不同的taskAffinity所修饰的Activity可以存在于相同的任务栈中，前提是被启动的Activity没有设定singleTask模式或singleInstance模式
   - singleTask模式下，不同的taskAffinity修饰的Activity只会存在于相同的TaskAffinity的Activity的任务栈




